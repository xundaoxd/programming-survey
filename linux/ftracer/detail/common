#!/usr/bin/env bash

self_dir=$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)
.   "$self_dir/utils"

tracefs="/sys/kernel/debug/tracing"

# do_event 'kmem:mm_page_alloc' ...
do_event() {
    local e
    for e in "$@"; do
        echo "$e" >> "$tracefs/set_event"
        event_push "$e"
        run_atexit "echo '!$e' >> $tracefs/set_event"
        run_atexit "event_pop"
    done
}
reset_event() {
    echo > "$tracefs/set_event"
}

# do_kprobe 'p:myopen do_sys_open filename=+0(%si):string' ...
do_kprobe() {
    local k
    local kprobe
    for k in "$@"; do
       read -r -a kprobe <<< "$k"
       do_run "echo '${k}' >> '$tracefs/kprobe_events'"
       run_atexit "echo -:${kprobe[0]#*:} >> $tracefs/kprobe_events"
    done
}
reset_kprobe() {
    echo > "$tracefs/kprobe_events"
}

# do_kprobe_enabled 'p do_sys_open filename=+0(%si):string' 'p:myopen do_sys_open filename=+0(%si):string' ...
do_kprobe_enabled() {
    local k
    local kprobe
    for k in "$@"; do
        read -r -a kprobe <<< "$k"
        if (( ${#kprobe[0]} == 1 )); then
           kprobe[0]="${kprobe[0]}:${kprobe[1]}"
        fi
        k=$(join ' ' "${kprobe[@]}")

        do_kprobe "$k"
        do_event "kprobes:${kprobe[0]#*:}"
    done
}

# do_uprobe 'p:bash /bin/bash:0x4245c0' ...
do_uprobe() {
    local u
    local uprobe
    for u in "$@"; do
        read -r -a uprobe <<< "$u"
        do_run "echo '${u}' >> $tracefs/uprobe_events"
        run_atexit "echo -:${uprobe[0]#*:} >> $tracefs/uprobe_events"
    done
}
reset_uprobe() {
    echo > "$tracefs/uprobe_events"
}

# do_uprobe_enabled 'p /bin/bash:0x4245c0' 'p:bash /bin/bash:0x4245c0' ...
do_uprobe_enabled() {
    local u
    local uprobe
    for u in "$@"; do
        read -r -a uprobe <<< "$u"
        if (( ${#uprobe[0]} == 1 )); then
            uprobe[0]="${uprobe[0]}:${uprobe[1]#*:}"
        fi
        if [[ "${uprobe[1]#*:}" != 0x* ]]; then
            local prog
            local sym
            local addr
            prog="${uprobe[1]%:*}"
            sym="${uprobe[1]#*:}"
            addr="$(get_addr "${prog}" "${sym}")"
            uprobe[1]="${prog}:${addr}"
        fi
        u=$(join ' ' "${uprobe[@]}")

        do_uprobe "$u"
        do_event "uprobes:${uprobe[0]#*:}"
    done
}

usage() {
    echo 'usage'
}

opt_events=()
opt_uprobes=()
opt_kprobes=()

opt_duration=
opt_stacktrace=

opt_pid=()
opt_followfork=
opt_filter=()
opt_trigger=()


do_main() {
    do_event "${opt_events[@]}"
    do_uprobe_enabled "${opt_uprobes[@]}"
    do_kprobe_enabled "${opt_kprobes[@]}"

    # cannot get userspace sym
    if [[ -n "$opt_stacktrace" ]]; then
        echo stacktrace > $tracefs/trace_options
        run_atexit "echo nostacktrace > $tracefs/trace_options"

        echo userstacktrace > $tracefs/trace_options
        run_atexit "echo nouserstacktrace > $tracefs/trace_options"

        echo sym-offset > $tracefs/trace_options
        run_atexit "echo nosym-offset > $tracefs/trace_options"

        echo sym-addr > $tracefs/trace_options
        run_atexit "echo nosym-addr > $tracefs/trace_options"
    fi

    if (( ${#opt_pid[@]} )); then
        echo "${opt_pid[*]}" > "$tracefs/set_event_pid"
        run_atexit "echo > $tracefs/set_event_pid"
        if [[ -n "$opt_followfork" ]]; then
            echo 1 > "$tracefs/options/event-fork"
            run_atexit "echo 0 > $tracefs/options/event-fork"
        fi
    fi

    for f in "${opt_filter[@]}"; do
        local -a tmp
        read -r -a tmp <<< "$f"
        if [ -z "${tmp[*]}" ]; then
            continue
        fi
        local -r e="${tmp[0]}"
        local -r filter="$(join ' ' "${tmp[@]:1}")"
        local -r epath="$tracefs/events/${e//://}"

        if [ -e "${epath}/filter" ]; then
            echo "${filter}" > "$epath/filter"
            run_atexit "echo 0 > $epath/filter"
        fi
    done

    for t in "${opt_trigger[@]}"; do
        local -a tmp
        read -r -a tmp <<< "$t"
        if [ -z "${tmp[*]}" ]; then
            continue
        fi
        local -r e="${tmp[0]}"
        local -r trigger="$(join ' ' "${tmp[@]:1}")"
        local -r epath="$tracefs/events/${e//://}"

        if [ -e "${epath}/trigger" ]; then
            echo "${trigger}" > "$epath/trigger"
            run_atexit "echo '!${trigger}' > $epath/trigger"
        fi
    done
}

main() {
    while (( $# )); do
        case "$1" in
            -h | --help)
                usage
                exit
                ;;
            -d | --duration)
                opt_duration="$2"
                shift 2
                ;;
            -s | --stacktrace)
                opt_stacktrace=1
                shift
                ;;
            -p | --pid)
                opt_pid+=("$2")
                shift 2
                ;;
            -ff | --follow-fork)
                opt_followfork=1
                shift
                ;;
            -f | --filter)
                opt_filter+=("$2")
                shift 2
                ;;
            -t | --trigger)
                opt_trigger+=("$2")
                shift 2
                ;;
            -u | --uprobe)
                opt_uprobes+=("$2")
                shift 2
                ;;
            -k | --kprobe)
                opt_kprobes+=("$2")
                shift 2
                ;;
            -e | --event)
                opt_events+=("$2")
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    do_main

    echo 1 > "$tracefs/tracing_on"
    run_atexit "echo 0 > $tracefs/tracing_on"

    if [ -n "$opt_duration" ]; then
        run_atexit "cat $tracefs/trace"
        sleep "$opt_duration"
    else
        cat "$tracefs/trace_pipe"
    fi
}

